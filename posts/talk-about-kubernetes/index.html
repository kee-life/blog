<!doctype html><html lang=en dir=ltr><head><meta charset=utf-8><meta name=viewport content='width=device-width,initial-scale=1'><meta name=description content="Kubernetes 近几年很热门，在各大技术论坛上被炒的很火。它提供了强大的容器编排能力，与此同时 DevOps 的概念也来到大家身边，它模糊了开发和运维之间的边界，让大家更容易的从开发到运维一个大型的分布式系统。 本文会以初学者的视角，希望能让读者更好地理解 Kubernetes 出现的背景、技术架构和设计理念，其中会涉及到部分实现原理。 # 背景 # Docker Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化，Docker 的实现主要依赖于 Linux 的 namespace、cgroups 和 UnionFS。 Docker 容器是完全使用沙箱机制，相互之间不会有任何接口。通过 Docker，实现进程、网络、挂载点和文件隔离，更好地利用宿主机资源。Docker 的强大到不需要关心宿主机的依赖，所有的一切都可以在镜像构建时完成，这也是 Docker 目前成为容器技术标准的原因。所以我们能看到在 Kubernetes 中 使用 Docker 作为容器（也支持 rkt）。 # 微服务 随着软件的规模越来越大，业务模式越来越复杂，用户量的上升、地区的分布、系统性能的苛刻要求促成服务架构的从单体变成 SOA 再到如今的微服务，未来还可能演变为 Service Mesh ，Serverless等等。 如今，一个完整的后端系统不再是单体应用架构了，伴随着多年前的 DDD 概念重新回到大家的视线中。现在的系统被不同的职责和功能被拆成多个服务，服务之间复杂的关系以及单机的单点性能瓶颈让部署和运维变得很复杂，所以部署和运维大型分布式系统的需求急迫待解决。 # Kubernetes 铺垫了这么多，终于说到本文的主角了。说 Kubernetes 之前，不得不提 Compose 和 Swarm，其实在 Kubernetes 还未一统江湖之前，这两个已经能实现大部分容器编排的能力了。但是在真正的大型系统上，它们却远远不如 Kubernetes。 在容器化和微服务时代，服务越来越多，容器个数也越来越多。Docker 如它 Logo 所示一样，一只只鲸鱼在大海里自由地游荡，而 Kubernetes 就像一个掌舵的船长，带着它们，有序的管理它们，这个过程其实就是容器编排。 Kubernetes 起源于 Google，很多设计都是源自于 Borg，是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes 的目标是让部署容器化的应用简单并且高效，并且提供了应用部署，规划，更新，维护的一种机制。 # 小结 至此，读者了解了 Kubernetes 的前世今生，它的出现使 DevOps 更加火热，普通的开发工程师也能做很多运维操作了。"><title>talk about kubernetes</title>
<link rel=canonical href=https://blog.elmle.cn/posts/talk-about-kubernetes/><link rel=stylesheet href=/scss/style.min.8e60baf4cd3fc55968717a6e39762f4d28ed7ef6007566b6c7970ad0fe907198.css><meta property='og:title' content="talk about kubernetes"><meta property='og:description' content="Kubernetes 近几年很热门，在各大技术论坛上被炒的很火。它提供了强大的容器编排能力，与此同时 DevOps 的概念也来到大家身边，它模糊了开发和运维之间的边界，让大家更容易的从开发到运维一个大型的分布式系统。 本文会以初学者的视角，希望能让读者更好地理解 Kubernetes 出现的背景、技术架构和设计理念，其中会涉及到部分实现原理。 # 背景 # Docker Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化，Docker 的实现主要依赖于 Linux 的 namespace、cgroups 和 UnionFS。 Docker 容器是完全使用沙箱机制，相互之间不会有任何接口。通过 Docker，实现进程、网络、挂载点和文件隔离，更好地利用宿主机资源。Docker 的强大到不需要关心宿主机的依赖，所有的一切都可以在镜像构建时完成，这也是 Docker 目前成为容器技术标准的原因。所以我们能看到在 Kubernetes 中 使用 Docker 作为容器（也支持 rkt）。 # 微服务 随着软件的规模越来越大，业务模式越来越复杂，用户量的上升、地区的分布、系统性能的苛刻要求促成服务架构的从单体变成 SOA 再到如今的微服务，未来还可能演变为 Service Mesh ，Serverless等等。 如今，一个完整的后端系统不再是单体应用架构了，伴随着多年前的 DDD 概念重新回到大家的视线中。现在的系统被不同的职责和功能被拆成多个服务，服务之间复杂的关系以及单机的单点性能瓶颈让部署和运维变得很复杂，所以部署和运维大型分布式系统的需求急迫待解决。 # Kubernetes 铺垫了这么多，终于说到本文的主角了。说 Kubernetes 之前，不得不提 Compose 和 Swarm，其实在 Kubernetes 还未一统江湖之前，这两个已经能实现大部分容器编排的能力了。但是在真正的大型系统上，它们却远远不如 Kubernetes。 在容器化和微服务时代，服务越来越多，容器个数也越来越多。Docker 如它 Logo 所示一样，一只只鲸鱼在大海里自由地游荡，而 Kubernetes 就像一个掌舵的船长，带着它们，有序的管理它们，这个过程其实就是容器编排。 Kubernetes 起源于 Google，很多设计都是源自于 Borg，是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes 的目标是让部署容器化的应用简单并且高效，并且提供了应用部署，规划，更新，维护的一种机制。 # 小结 至此，读者了解了 Kubernetes 的前世今生，它的出现使 DevOps 更加火热，普通的开发工程师也能做很多运维操作了。"><meta property='og:url' content='https://blog.elmle.cn/posts/talk-about-kubernetes/'><meta property='og:site_name' content='Personal blog'><meta property='og:type' content='article'><meta property='article:section' content='Posts'><meta property='article:published_time' content='2019-01-25T11:00:00+00:00'><meta property='article:modified_time' content='2019-01-25T11:00:00+00:00'><meta name=twitter:title content="talk about kubernetes"><meta name=twitter:description content="Kubernetes 近几年很热门，在各大技术论坛上被炒的很火。它提供了强大的容器编排能力，与此同时 DevOps 的概念也来到大家身边，它模糊了开发和运维之间的边界，让大家更容易的从开发到运维一个大型的分布式系统。 本文会以初学者的视角，希望能让读者更好地理解 Kubernetes 出现的背景、技术架构和设计理念，其中会涉及到部分实现原理。 # 背景 # Docker Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化，Docker 的实现主要依赖于 Linux 的 namespace、cgroups 和 UnionFS。 Docker 容器是完全使用沙箱机制，相互之间不会有任何接口。通过 Docker，实现进程、网络、挂载点和文件隔离，更好地利用宿主机资源。Docker 的强大到不需要关心宿主机的依赖，所有的一切都可以在镜像构建时完成，这也是 Docker 目前成为容器技术标准的原因。所以我们能看到在 Kubernetes 中 使用 Docker 作为容器（也支持 rkt）。 # 微服务 随着软件的规模越来越大，业务模式越来越复杂，用户量的上升、地区的分布、系统性能的苛刻要求促成服务架构的从单体变成 SOA 再到如今的微服务，未来还可能演变为 Service Mesh ，Serverless等等。 如今，一个完整的后端系统不再是单体应用架构了，伴随着多年前的 DDD 概念重新回到大家的视线中。现在的系统被不同的职责和功能被拆成多个服务，服务之间复杂的关系以及单机的单点性能瓶颈让部署和运维变得很复杂，所以部署和运维大型分布式系统的需求急迫待解决。 # Kubernetes 铺垫了这么多，终于说到本文的主角了。说 Kubernetes 之前，不得不提 Compose 和 Swarm，其实在 Kubernetes 还未一统江湖之前，这两个已经能实现大部分容器编排的能力了。但是在真正的大型系统上，它们却远远不如 Kubernetes。 在容器化和微服务时代，服务越来越多，容器个数也越来越多。Docker 如它 Logo 所示一样，一只只鲸鱼在大海里自由地游荡，而 Kubernetes 就像一个掌舵的船长，带着它们，有序的管理它们，这个过程其实就是容器编排。 Kubernetes 起源于 Google，很多设计都是源自于 Borg，是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes 的目标是让部署容器化的应用简单并且高效，并且提供了应用部署，规划，更新，维护的一种机制。 # 小结 至此，读者了解了 Kubernetes 的前世今生，它的出现使 DevOps 更加火热，普通的开发工程师也能做很多运维操作了。"><link rel="shortcut icon" href=/favicon-32x32.png></head><body class=article-page><script>(function(){const e="StackColorScheme";localStorage.getItem(e)||localStorage.setItem(e,"auto")})()</script><script>(function(){const t="StackColorScheme",e=localStorage.getItem(t),n=window.matchMedia("(prefers-color-scheme: dark)").matches===!0;e=="dark"||e==="auto"&&n?document.documentElement.dataset.scheme="dark":document.documentElement.dataset.scheme="light"})()</script><div class="container main-container flex on-phone--column extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label="Toggle Menu">
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header><figure class=site-avatar><a href=/><img src=/img/avatar_huc7435e6901951db8545b013f2b5a7a83_1936738_300x0_resize_box_3.png width=300 height=324 class=site-logo loading=lazy alt=Avatar>
</a><span class=emoji>🍥</span></figure><div class=site-meta><h1 class=site-name><a href=/>Personal blog</a></h1><h2 class=site-description>About coding, technology, books, movies and life.</h2></div></header><ol class=menu-social><li><a href=https://github.com/kee-life/blog target=_blank title=GitHub rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-github" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M9 19c-4.3 1.4-4.3-2.5-6-3m12 5v-3.5c0-1 .1-1.4-.5-2 2.8-.3 5.5-1.4 5.5-6a4.6 4.6.0 00-1.3-3.2 4.2 4.2.0 00-.1-3.2s-1.1-.3-3.5 1.3a12.3 12.3.0 00-6.2.0C6.5 2.8 5.4 3.1 5.4 3.1a4.2 4.2.0 00-.1 3.2A4.6 4.6.0 004 9.5c0 4.6 2.7 5.7 5.5 6-.6.6-.6 1.2-.5 2V21"/></svg></a></li><li><a href=index.xml target=_blank title=Rss rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-rss" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="5" cy="19" r="1"/><path d="M4 4a16 16 0 0116 16"/><path d="M4 11a9 9 0 019 9"/></svg></a></li><li><a href=https://twitter.com target=_blank title=Twitter rel=me><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-brand-twitter" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M22 4.01c-1 .49-1.98.689-3 .99-1.121-1.265-2.783-1.335-4.38-.737S11.977 6.323 12 8v1c-3.245.083-6.135-1.395-8-4 0 0-4.182 7.433 4 11-1.872 1.247-3.739 2.088-6 2 3.308 1.803 6.913 2.423 10.034 1.517 3.58-1.04 6.522-3.723 7.651-7.742a13.84 13.84.0 00.497-3.753C20.18 7.773 21.692 5.25 22 4.009z"/></svg></a></li></ol><ol class=menu id=main-menu><li><a href=/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg>
<span>Home</span></a></li><li><a href=/archives/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg>
<span>Archives</span></a></li><li><a href=/search/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-search" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="10" cy="10" r="7"/><line x1="21" y1="21" x2="15" y2="15"/></svg>
<span>Search</span></a></li><li><a href=/about/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg>
<span>About</span></a></li><li class=menu-bottom-section><ol class=menu><li id=dark-mode-toggle><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-left" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="8" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-toggle-right" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="16" cy="12" r="2"/><rect x="2" y="6" width="20" height="12" rx="6"/></svg>
<span>Dark Mode</span></li></ol></li></ol></aside><aside class="sidebar right-sidebar sticky"><section class="widget archives"><div class=widget-icon><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-hash" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><line x1="5" y1="9" x2="19" y2="9"/><line x1="5" y1="15" x2="19" y2="15"/><line x1="11" y1="4" x2="7" y2="20"/><line x1="17" y1="4" x2="13" y2="20"/></svg></div><h2 class="widget-title section-title">Table of contents</h2><div class=widget--toc><nav id=TableOfContents><ol><li><a href=#docker>Docker</a></li><li><a href=#微服务>微服务</a></li><li><a href=#kubernetes>Kubernetes</a></li><li><a href=#小结>小结</a></li></ol><ol><li><a href=#申明式vs命令式>申明式VS命令式</a></li><li><a href=#显示的api>显示的API</a></li><li><a href=#无侵入性>无侵入性</a></li><li><a href=#有状态的移植>有状态的移植</a></li></ol><ol><li><a href=#master>Master</a></li><li><a href=#node>Node</a></li></ol><ol><li><a href=#创建-kubernetes-集群>创建 Kubernetes 集群</a></li><li><a href=#部署应用>部署应用</a></li><li><a href=#查看pods-和-nodes>查看Pods 和 Nodes</a></li><li><a href=#service-与-labelselector>Service 与 LabelSelector</a></li><li><a href=#应用扩用>应用扩用</a></li><li><a href=#更新应用>更新应用</a></li></ol></nav></div></section></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><header class=article-category><a href=/categories/k8s/>K8s
</a><a href=/categories/kubernetes/>Kubernetes</a></header><div class=article-title-wrapper><h2 class=article-title><a href=/posts/talk-about-kubernetes/>talk about kubernetes</a></h2></div><footer class=article-time><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-calendar-time" width="56" height="56" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><path d="M11.795 21H5a2 2 0 01-2-2V7a2 2 0 012-2h12a2 2 0 012 2v4"/><circle cx="18" cy="18" r="4"/><path d="M15 3v4"/><path d="M7 3v4"/><path d="M3 11h16"/><path d="M18 16.496V18l1 1"/></svg>
<time class=article-time--published>Jan 25, 2019</time></div><div><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg>
<time class=article-time--reading>3 minute read</time></div></footer></div></header><section class=article-content><p>Kubernetes 近几年很热门，在各大技术论坛上被炒的很火。它提供了强大的容器编排能力，与此同时 DevOps 的概念也来到大家身边，它模糊了开发和运维之间的边界，让大家更容易的从开发到运维一个大型的分布式系统。
<img src=/posts/talk-about-kubernetes/63d17911492f6663d6430bb79375924d.png width=900 height=431 srcset="/posts/talk-about-kubernetes/63d17911492f6663d6430bb79375924d_hu15296541e29d7f08da1453e6875eb4ac_50231_480x0_resize_box_3.png 480w, /posts/talk-about-kubernetes/63d17911492f6663d6430bb79375924d_hu15296541e29d7f08da1453e6875eb4ac_50231_1024x0_resize_box_3.png 1024w" loading=lazy alt=!Center class=gallery-image data-flex-grow=208 data-flex-basis=501px>
本文会以初学者的视角，希望能让读者更好地理解 Kubernetes 出现的背景、技术架构和设计理念，其中会涉及到部分实现原理。</p><h1 id=背景><a href=#%e8%83%8c%e6%99%af>#</a>
背景</h1><hr><h2 id=docker><a href=#docker>#</a>
Docker</h2><p>Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化，Docker 的实现主要依赖于 Linux 的 namespace、cgroups 和 UnionFS。
<img src=/posts/talk-about-kubernetes/23276458b2b122fee8d992647b9c9b4a.png width=849 height=199 srcset="/posts/talk-about-kubernetes/23276458b2b122fee8d992647b9c9b4a_hu178c00c3f75ae27dc77cef4ab533be91_117487_480x0_resize_box_3.png 480w, /posts/talk-about-kubernetes/23276458b2b122fee8d992647b9c9b4a_hu178c00c3f75ae27dc77cef4ab533be91_117487_1024x0_resize_box_3.png 1024w" loading=lazy alt=Center class=gallery-image data-flex-grow=426 data-flex-basis=1023px>
Docker 容器是完全使用沙箱机制，相互之间不会有任何接口。通过 Docker，实现进程、网络、挂载点和文件隔离，更好地利用宿主机资源。Docker 的强大到不需要关心宿主机的依赖，所有的一切都可以在镜像构建时完成，这也是 Docker 目前成为容器技术标准的原因。所以我们能看到在 Kubernetes 中 使用 Docker 作为容器（也支持 rkt）。</p><h2 id=微服务><a href=#%e5%be%ae%e6%9c%8d%e5%8a%a1>#</a>
微服务</h2><p>随着软件的规模越来越大，业务模式越来越复杂，用户量的上升、地区的分布、系统性能的苛刻要求促成服务架构的从单体变成 SOA 再到如今的微服务，未来还可能演变为 Service Mesh ，Serverless等等。
<img src=/posts/talk-about-kubernetes/47c8f1e1d2b175c2aa1128268d38d80b.png width=1324 height=574 srcset="/posts/talk-about-kubernetes/47c8f1e1d2b175c2aa1128268d38d80b_hud6a18ecf52706326135bdc1d15e7153b_697987_480x0_resize_box_3.png 480w, /posts/talk-about-kubernetes/47c8f1e1d2b175c2aa1128268d38d80b_hud6a18ecf52706326135bdc1d15e7153b_697987_1024x0_resize_box_3.png 1024w" loading=lazy alt=Center class=gallery-image data-flex-grow=230 data-flex-basis=553px>
如今，一个完整的后端系统不再是单体应用架构了，伴随着多年前的 DDD 概念重新回到大家的视线中。现在的系统被不同的职责和功能被拆成多个服务，服务之间复杂的关系以及单机的单点性能瓶颈让部署和运维变得很复杂，所以部署和运维大型分布式系统的需求急迫待解决。</p><h2 id=kubernetes><a href=#kubernetes>#</a>
Kubernetes</h2><p>铺垫了这么多，终于说到本文的主角了。说 Kubernetes 之前，不得不提 Compose 和 Swarm，其实在 Kubernetes 还未一统江湖之前，这两个已经能实现大部分容器编排的能力了。但是在真正的大型系统上，它们却远远不如 Kubernetes。
<img src=/posts/talk-about-kubernetes/04ad8d9ae828c06177c17d0cb8e3403e.png width=260 height=170 srcset="/posts/talk-about-kubernetes/04ad8d9ae828c06177c17d0cb8e3403e_hua1112b74cd954ccad90d06bc52545349_9248_480x0_resize_box_3.png 480w, /posts/talk-about-kubernetes/04ad8d9ae828c06177c17d0cb8e3403e_hua1112b74cd954ccad90d06bc52545349_9248_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=152 data-flex-basis=367px>
在容器化和微服务时代，服务越来越多，容器个数也越来越多。Docker 如它 Logo 所示一样，一只只鲸鱼在大海里自由地游荡，而 Kubernetes 就像一个掌舵的船长，带着它们，有序的管理它们，这个过程其实就是容器编排。</p><p>Kubernetes 起源于 Google，很多设计都是源自于 Borg，是一个开源的，用于管理云平台中多个主机上的容器化的应用，Kubernetes 的目标是让部署容器化的应用简单并且高效，并且提供了应用部署，规划，更新，维护的一种机制。</p><h2 id=小结><a href=#%e5%b0%8f%e7%bb%93>#</a>
小结</h2><p>至此，读者了解了 Kubernetes 的前世今生，它的出现使 DevOps 更加火热，普通的开发工程师也能做很多运维操作了。</p><h1 id=设计理念><a href=#%e8%ae%be%e8%ae%a1%e7%90%86%e5%bf%b5>#</a>
设计理念</h1><p>这一部分，我们会围绕 Kubernetes 的四个设计理念看看这些做法能给我们带来什么。</p><h2 id=申明式vs命令式><a href=#%e7%94%b3%e6%98%8e%e5%bc%8fvs%e5%91%bd%e4%bb%a4%e5%bc%8f>#</a>
申明式VS命令式</h2><p>声明式和命令式是截然不同的两种编程方式，在命令式 API 中，我们可以直接发出服务器要执行的命令，例如： “运行容器”、“停止容器”等；在声明式 API 中，我们声明系统要执行的操作，系统将不断向该状态驱动。</p><p><img src=/posts/talk-about-kubernetes/54a06e23d807ee8002e1f7d8eb2dedd3.png width=540 height=291 srcset="/posts/talk-about-kubernetes/54a06e23d807ee8002e1f7d8eb2dedd3_hu0f7ca2b1c8f0749e6585b9aa827672c9_29972_480x0_resize_box_3.png 480w, /posts/talk-about-kubernetes/54a06e23d807ee8002e1f7d8eb2dedd3_hu0f7ca2b1c8f0749e6585b9aa827672c9_29972_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=185 data-flex-basis=445px>
我们常用的 SQL 就是一种声明式语言，告诉数据库想要的结果集，数据库会帮我们设计获取这个结果集的执行路径，并返回结果集。众所周知，使用 SQL 语言获取数据，要比自行编写处理过程去获取数据容易的多。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span><span class=lnt>22
</span><span class=lnt>23
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-Yaml data-lang=Yaml><span class=line><span class=cl><span class=nt>apiVersion</span><span class=p>:</span><span class=w> </span><span class=l>extensions/v1beta1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>kind</span><span class=p>:</span><span class=w> </span><span class=l>Deployment</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>etcd-operator</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w></span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>replicas</span><span class=p>:</span><span class=w> </span><span class=m>1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>  </span><span class=nt>template</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>metadata</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>labels</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>etcd-operator</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>    </span><span class=nt>spec</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span><span class=nt>containers</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>      </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>etcd-operator</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>image</span><span class=p>:</span><span class=w> </span><span class=l>quay.io/coreos/etcd-operator:v0.2.1</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span><span class=nt>env</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>MY_POD_NAMESPACE</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>valueFrom</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>fieldRef</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>fieldPath</span><span class=p>:</span><span class=w> </span><span class=l>metadata.namespace</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>        </span>- <span class=nt>name</span><span class=p>:</span><span class=w> </span><span class=l>MY_POD_NAME</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>          </span><span class=nt>valueFrom</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>            </span><span class=nt>fieldRef</span><span class=p>:</span><span class=w>
</span></span></span><span class=line><span class=cl><span class=w>              </span><span class=nt>fieldPath</span><span class=p>:</span><span class=w> </span><span class=l>metadata.name</span><span class=w>
</span></span></span></code></pre></td></tr></table></div></div><p>我们来看看相同设计的 YAML，利用它，我们可以告诉 Kubernetes 最终想要的是什么，然后 Kubernetes 会完成目标。</p><p>声明式 API 使系统更加健壮，在分布式系统中，任何组件都可能随时出现故障。当组件恢复时，需要弄清楚要做什么，使用命令式 API 时，处理起来就很棘手。但是使用声明式 API ，组件只需查看 API 服务器的当前状态，即可确定它需要执行的操作。</p><h2 id=显示的api><a href=#%e6%98%be%e7%a4%ba%e7%9a%84api>#</a>
显示的API</h2><p>Kubernetes 是透明的，它没有隐藏的内部 API。换句话说 Kubernetes 系统内部用来交互的 API 和我们用来与 Kubernetes 交互的 API 相同。</p><p><img src=/posts/talk-about-kubernetes/380f507ad6aadd16649f230786054014.png width=1638 height=798 srcset="/posts/talk-about-kubernetes/380f507ad6aadd16649f230786054014_huac88f75c701d8afa5c064ab178ee8311_130073_480x0_resize_box_3.png 480w, /posts/talk-about-kubernetes/380f507ad6aadd16649f230786054014_huac88f75c701d8afa5c064ab178ee8311_130073_1024x0_resize_box_3.png 1024w" loading=lazy alt=|Center class=gallery-image data-flex-grow=205 data-flex-basis=492px>
这样做的好处是，当 Kubernetes 默认的组件无法满足我们的需求时，我们可以利用已有的 API 实现我们自定义的特性。</p><h2 id=无侵入性><a href=#%e6%97%a0%e4%be%b5%e5%85%a5%e6%80%a7>#</a>
无侵入性</h2><p>感谢 Docker 容器技术的流行，使得 Kubernetes 为大家提供了无缝的使用方式。在容器化的时代，我们的应用达到镜像后，不需要改动就可以遨游在 Kubernetes 集群中。</p><p><img src=/posts/talk-about-kubernetes/66fd02808d707f959c78782fcd3decf6.png width=650 height=530 srcset="/posts/talk-about-kubernetes/66fd02808d707f959c78782fcd3decf6_hu03ee812fa474419fb851478b210bf659_97931_480x0_resize_box_3.png 480w, /posts/talk-about-kubernetes/66fd02808d707f959c78782fcd3decf6_hu03ee812fa474419fb851478b210bf659_97931_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=122 data-flex-basis=294px>
Kubernetes 还提供存储 Secret、Configuration 等包含但不局限于密码、证书、容器镜像信息、应用启动参数能力。如此，Kubernetes 以一种友好的方式将这些东西注入 Pod，减少了大家的工作量，而无需重写或者很大幅度改变原有的应用代码。</p><h2 id=有状态的移植><a href=#%e6%9c%89%e7%8a%b6%e6%80%81%e7%9a%84%e7%a7%bb%e6%a4%8d>#</a>
有状态的移植</h2><p>在有状态的存储场景下，Kubernetes 如何做到对于服务和存储的分离呢？假设一个大型分布式系统使用了多家云厂商的存储方案，如何做到开发者无感于底层的存储技术体系，并且做到方便的移植？</p><p><img src=/posts/talk-about-kubernetes/32ca12fa44593a2b5907f1bcc289cfb5.png width=859 height=434 srcset="/posts/talk-about-kubernetes/32ca12fa44593a2b5907f1bcc289cfb5_hu93ec51a13c3e6005ce18cc641e59b263_37318_480x0_resize_box_3.png 480w, /posts/talk-about-kubernetes/32ca12fa44593a2b5907f1bcc289cfb5_hu93ec51a13c3e6005ce18cc641e59b263_37318_1024x0_resize_box_3.png 1024w" loading=lazy alt=|Center class=gallery-image data-flex-grow=197 data-flex-basis=475px>
为了实现这一目标，Kubernetes 引入了 PersistentVolumeClaim（PVC）和 PersistentVolume（PV）API 对象。这些对象将存储实现与存储使用分离。</p><p>PersistentVolumeClaim 对象用作用户以与实现无关的方式请求存储的方法，通过它来抹除对底层 PersistentVolume 的差异性。这样就使 Kubernetes 拥有了跨集群的移植能力。</p><h1 id=架构><a href=#%e6%9e%b6%e6%9e%84>#</a>
架构</h1><p>首先要提及的是 Kubernetes 使用很具代表性的 C/S 架构方式，Client 可以使用 kubectl 命令行或者 RESTful 接口与 Kubernetes 集群进行交互。下面这张图是从宏观上看 Kubernetes 的整体架构，每一个 Kubernetes 集群都由 Master 节点 和 很多的 Node 节点组成。
<img src=/posts/talk-about-kubernetes/d557ade0b967dd60040d459d9c443c05.png width=1858 height=1126 srcset="/posts/talk-about-kubernetes/d557ade0b967dd60040d459d9c443c05_hu9efe30128b226a9b9b95be70f73f29c0_759222_480x0_resize_box_3.png 480w, /posts/talk-about-kubernetes/d557ade0b967dd60040d459d9c443c05_hu9efe30128b226a9b9b95be70f73f29c0_759222_1024x0_resize_box_3.png 1024w" loading=lazy alt=|Center class=gallery-image data-flex-grow=165 data-flex-basis=396px></p><h2 id=master><a href=#master>#</a>
Master</h2><p><img src=/posts/talk-about-kubernetes/dda50cef366f90eeb2cd09d9ec6c2371.png width=1600 height=1067 srcset="/posts/talk-about-kubernetes/dda50cef366f90eeb2cd09d9ec6c2371_hu612b5222a5ffa5504ac4f4f64e0cb81b_84266_480x0_resize_box_3.png 480w, /posts/talk-about-kubernetes/dda50cef366f90eeb2cd09d9ec6c2371_hu612b5222a5ffa5504ac4f4f64e0cb81b_84266_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=149 data-flex-basis=359px>
Master 是 Kubernetes 集群的管理节点，负责管理集群，提供集群的资源数据访问入口。拥有 Etcd 存储服务，运行 API Server 进程，Controller Manager 服务进程及 Scheduler 服务进程，关联工作节点 Node。</p><p>Kubernetes API Server 提供 HTTP Rest 接口的关键服务进程，是Kubernetes里所有资源的增、删、改、查等操作的唯一入口。也是集群控制的入口进程；
Kubernetes Controller Manager 是 Kubernetes 所有资源对象的自动化控制中心，它驱使集群向着我们所需要的最终目的状态；
Kubernetes Schedule是 负责 Pod 调度的进程。</p><h2 id=node><a href=#node>#</a>
Node</h2><p><img src=/posts/talk-about-kubernetes/05f3ba08afd94c864c229039b3711248.png width=1600 height=1067 srcset="/posts/talk-about-kubernetes/05f3ba08afd94c864c229039b3711248_hu612b5222a5ffa5504ac4f4f64e0cb81b_97013_480x0_resize_box_3.png 480w, /posts/talk-about-kubernetes/05f3ba08afd94c864c229039b3711248_hu612b5222a5ffa5504ac4f4f64e0cb81b_97013_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=149 data-flex-basis=359px>
Node 是 Kubernetes 集群架构中运行 Pod 的服务节点。Node 是 Kubernetes 集群操作的单元，用来承载被分配 Pod 的运行，是 Pod 运行的宿主机。关联 Master 管理节点，拥有名称和 IP、系统资源信息。运行 Docker Runtime、kubelet 和 kube-proxy。</p><p>kubelet 负责对Pod对于的容器的创建、启停等任务，发送宿主机当前状态；
kube-proxy 实现 Kubernetes Service 的通信与负载均衡机制的重要组件；
Docker Runtime 负责本机容器的创建和管理工作。</p><h1 id=实现原理><a href=#%e5%ae%9e%e7%8e%b0%e5%8e%9f%e7%90%86>#</a>
实现原理</h1><p>为了尽可能的让读者能明白 Kubernetes 是如何运作的，这里不会涉及到具体的细节实现，如有读者感兴趣可以自行参阅官网文档。这里以一个简单的应用部署示例来阐述一些概念和原理。</p><h2 id=创建-kubernetes-集群><a href=#%e5%88%9b%e5%bb%ba-kubernetes-%e9%9b%86%e7%be%a4>#</a>
创建 Kubernetes 集群</h2><p><img src=/posts/talk-about-kubernetes/1fc655d24340f8b82234ccdb662f5c9e.png width=998 height=756 srcset="/posts/talk-about-kubernetes/1fc655d24340f8b82234ccdb662f5c9e_hu00253a23c3444b4652e4ab00db0086a2_161523_480x0_resize_box_3.png 480w, /posts/talk-about-kubernetes/1fc655d24340f8b82234ccdb662f5c9e_hu00253a23c3444b4652e4ab00db0086a2_161523_1024x0_resize_box_3.png 1024w" loading=lazy alt=|Center class=gallery-image data-flex-grow=132 data-flex-basis=316px>
介绍架构的时候我们知道，Kubernetes 集群由 Master 和 Node 组成。</p><p>Master 管理集群的所有行为例如：应用调度、改变应用的状态，扩缩容，更新/降级应用等。</p><p>Node 可以是是一个虚拟机或者物理机，它是应用的“逻辑主机”，每一个 Node 拥有一个 Kubelet，Kubelet 负责管理 Node 节点与 Master 节点的交互，同时 Node 还需要有容器操作的能力，比如 Docker 或者 rkt。理论上来说，一个 Kubernetes 为了应对生产环境的流量，最少部署3个 Node 节点。</p><p>当我们需要在 Kubernetes 上部署应用时，我们告诉 Master 节点，Master 会调度容器跑在合适的 Node 节点上。</p><p>我们可以使用 Minikube 在本地搭一个单 Node 的 Kubernetes 集群。</p><h2 id=部署应用><a href=#%e9%83%a8%e7%bd%b2%e5%ba%94%e7%94%a8>#</a>
部署应用</h2><p><img src=/posts/talk-about-kubernetes/09ec3314ca193a0bf81f847c81b0c46a.png width=1028 height=764 srcset="/posts/talk-about-kubernetes/09ec3314ca193a0bf81f847c81b0c46a_hu20b2d548ef3f036c1093203666470f56_178367_480x0_resize_box_3.png 480w, /posts/talk-about-kubernetes/09ec3314ca193a0bf81f847c81b0c46a_hu20b2d548ef3f036c1093203666470f56_178367_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=134 data-flex-basis=322px>
当创建好一个 Kubernetes 集群后，就可以把容器化的应用跑在上面了。我们需要创建一个 Deployment，它会告诉 Kubernetes Master 如何去创建应用，也可以来更新应用。</p><p>当应用实例创建后，Deployment 会不断的观察这些实例，如果 Node 上的 Pod 挂了，Deployment 会自动创建新的实例并且替换它。相比传统脚本运维的方式，这种方式更加优雅。</p><p>我们能通过 kubectl 命令或者 YAML 文件来创建 Deployment，在创建的时候需要指定应用镜像和要跑的实例个数，之后 Kubernetes 会自动帮我们处理。</p><h2 id=查看pods-和-nodes><a href=#%e6%9f%a5%e7%9c%8bpods-%e5%92%8c-nodes>#</a>
查看Pods 和 Nodes</h2><p>下面来介绍下 Pod 和 Node：
<img src=/posts/talk-about-kubernetes/99a2ea45046cb9f78b065e31e28b7563.png width=1268 height=484 srcset="/posts/talk-about-kubernetes/99a2ea45046cb9f78b065e31e28b7563_hudf8f88e0419980a4f29157c5d29d5ccc_110057_480x0_resize_box_3.png 480w, /posts/talk-about-kubernetes/99a2ea45046cb9f78b065e31e28b7563_hudf8f88e0419980a4f29157c5d29d5ccc_110057_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=261 data-flex-basis=628px>
当我们创建好 Deployment 的时候，Kubernetes 会自动创建 Pod 来承载应用实例。Pod 是一个抽象的概念，像一个“逻辑主机”，它代表一组应用容器的集合，这些应用容器共享资源，包括存储，网络和相同的内部集群 IP。</p><p><img src=/posts/talk-about-kubernetes/ef3a0b122575286ed2b6c1a89611b05a.png width=1096 height=932 srcset="/posts/talk-about-kubernetes/ef3a0b122575286ed2b6c1a89611b05a_hu7365a734c2927fabd7316ebd938e834e_163286_480x0_resize_box_3.png 480w, /posts/talk-about-kubernetes/ef3a0b122575286ed2b6c1a89611b05a_hu7365a734c2927fabd7316ebd938e834e_163286_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=117 data-flex-basis=282px>
任何一个 Pod 都需要跑在一个 Node 节点上。Node 是一个“虚拟机器”，它可以是虚拟机也可以是物理机，一个 Node 可以有多个 Pods，Kubernetes 会自动调度 Pod 到合适的 Node 上。</p><h2 id=service-与-labelselector><a href=#service-%e4%b8%8e-labelselector>#</a>
Service 与 LabelSelector</h2><p>Pods 终有一死，也就是说 Pods 也有自己的生命周期，当一个 Pod 挂了的时候，ReplicaSet 会创建新的，并且调度到合适的 Node 节点上。考虑下访问的问题，Pod 替换伴随着 IP 的变化，对于访问者来说，变化的 IP 是合理的；并且当有多个 Pod 节点时，如何 SLB 访问也是个问题，Service 就是为了解决这些问题的。
<img src=/posts/talk-about-kubernetes/7cd5ab174d094e163a41a5edbab7cd70.png width=1176 height=1076 srcset="/posts/talk-about-kubernetes/7cd5ab174d094e163a41a5edbab7cd70_huee4c8d5eeb689ad5c70a71ad589f78af_188452_480x0_resize_box_3.png 480w, /posts/talk-about-kubernetes/7cd5ab174d094e163a41a5edbab7cd70_huee4c8d5eeb689ad5c70a71ad589f78af_188452_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=109 data-flex-basis=262px></p><p>Service 是一个抽象的概念，它定义了一组逻辑 Pods，并且提供访问它们的策略。和其他对象一样，Service 也能通过 kubectl 或者 YAML 创建。Service 定义的 Pod 可以写在 LabelSelector 选项中（下文会介绍），也存在不指定 Pods 的情况，这种比较复杂，感兴趣的读者可以自行查阅资料。</p><p>Service 有以下几种类型：</p><ul><li>ClusterIP（默认）：在集群中内部IP上暴露服务，此类型使Service只能从群集中访问；</li><li>NodePort：通过每个 Node 上的 IP 和静态端口（NodePort）暴露服务。NodePort 服务会路由到 ClusterIP 服务，这个 ClusterIP 服务会自动创建。通过请求 :，可以从集群的外部访问一个 NodePort 服务；</li><li>LoadBalancer：使用云提供商的负载均衡器，可以向外部暴露服务。外部的负载均衡器可以路由到 NodePort 服务和 ClusterIP 服务；</li><li>ExternalName：通过返回 CNAME 和它的值，（适用于外部 DNS 的场景）
<img src=/posts/talk-about-kubernetes/6a96452d6cd2670674bd774d34a5080d.png width=1064 height=1052 srcset="/posts/talk-about-kubernetes/6a96452d6cd2670674bd774d34a5080d_hubdb7138ea5879e8c979a87cb720c6338_196447_480x0_resize_box_3.png 480w, /posts/talk-about-kubernetes/6a96452d6cd2670674bd774d34a5080d_hubdb7138ea5879e8c979a87cb720c6338_196447_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=101 data-flex-basis=242px></li></ul><p>Labels 和 Selectors 能够让 Kubernetes 拥有逻辑运算的能力，有点像 SQL。举个例子：可以查找 app=hello_word 的所有对象，也可以查找 app in (a,b,c) abc的所有对象。</p><p>Labels是一个绑定在对象上的 K/V 结构，它可以在创建或者之后的时候的定义，在任何时候都可以改变。</p><h2 id=应用扩用><a href=#%e5%ba%94%e7%94%a8%e6%89%a9%e7%94%a8>#</a>
应用扩用</h2><p>前文提到我们可以使用 Deployment 增加实例个数，下图是原始的集群状态：
<img src=/posts/talk-about-kubernetes/30662524be0c59492d3a20af6e7fa111.png width=996 height=904 srcset="/posts/talk-about-kubernetes/30662524be0c59492d3a20af6e7fa111_huc3c94e4dc1fa62e1a0a8a92267c682f5_90027_480x0_resize_box_3.png 480w, /posts/talk-about-kubernetes/30662524be0c59492d3a20af6e7fa111_huc3c94e4dc1fa62e1a0a8a92267c682f5_90027_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=110 data-flex-basis=264px>
我们可以随意的更改 replicas （实例个数）来扩容，当我们更改了 Deployment 中的 replicas 值时，Kubernetes 会自动帮我们达到想要的目标实例个数，如下图：
<img src=/posts/talk-about-kubernetes/37cdf81ebe1663f74fe80567b6c6effc.png width=966 height=882 srcset="/posts/talk-about-kubernetes/37cdf81ebe1663f74fe80567b6c6effc_hu6502f86c4fa40d28d86ee8c6a3227dc5_118220_480x0_resize_box_3.png 480w, /posts/talk-about-kubernetes/37cdf81ebe1663f74fe80567b6c6effc_hu6502f86c4fa40d28d86ee8c6a3227dc5_118220_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=109 data-flex-basis=262px></p><h2 id=更新应用><a href=#%e6%9b%b4%e6%96%b0%e5%ba%94%e7%94%a8>#</a>
更新应用</h2><p>更新应用和扩容类似，我们可以更改 Deployment 中的容器镜像，然后 Kubernetes 会帮住我们应用更新（蓝绿、金丝雀等方式），通过此功能，我们还可以实现切换应用环境、回滚、不停机CCD。下面是部署的过程，需要注意的是，我们可以指定新创建的 Pod 最大个数和不可用 Pod 最大个数：
<img src=/posts/talk-about-kubernetes/2cf23e0bc1253e7c26930310101c12cb.png width=914 height=898 srcset="/posts/talk-about-kubernetes/2cf23e0bc1253e7c26930310101c12cb_hu2550f108d4584467901510516cf0cd97_117397_480x0_resize_box_3.png 480w, /posts/talk-about-kubernetes/2cf23e0bc1253e7c26930310101c12cb_hu2550f108d4584467901510516cf0cd97_117397_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=101 data-flex-basis=244px>
<img src=/posts/talk-about-kubernetes/acacffc995f97439c0cb729ad3110758.png width=1102 height=886 srcset="/posts/talk-about-kubernetes/acacffc995f97439c0cb729ad3110758_hu29876da1df5676850b6f1c08d4cb83db_139408_480x0_resize_box_3.png 480w, /posts/talk-about-kubernetes/acacffc995f97439c0cb729ad3110758_hu29876da1df5676850b6f1c08d4cb83db_139408_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=124 data-flex-basis=298px>
<img src=/posts/talk-about-kubernetes/caeb3f62ecadfbc9bdf80d5401c8497a.png width=1082 height=900 srcset="/posts/talk-about-kubernetes/caeb3f62ecadfbc9bdf80d5401c8497a_hu99d48f31215c6291b3469dd0fa6e6e24_131445_480x0_resize_box_3.png 480w, /posts/talk-about-kubernetes/caeb3f62ecadfbc9bdf80d5401c8497a_hu99d48f31215c6291b3469dd0fa6e6e24_131445_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=120 data-flex-basis=288px>
<img src=/posts/talk-about-kubernetes/0e994b5fea1d82e79eab0e83f7fb2b4f.png width=1126 height=882 srcset="/posts/talk-about-kubernetes/0e994b5fea1d82e79eab0e83f7fb2b4f_hud5331a53709f90a126c524fde72286f1_131393_480x0_resize_box_3.png 480w, /posts/talk-about-kubernetes/0e994b5fea1d82e79eab0e83f7fb2b4f_hud5331a53709f90a126c524fde72286f1_131393_1024x0_resize_box_3.png 1024w" loading=lazy class=gallery-image data-flex-grow=127 data-flex-basis=306px></p><h1 id=总结><a href=#%e6%80%bb%e7%bb%93>#</a>
总结</h1><p>到了最后，大家对 Kubernetes 能有个大概的了解了，但 Kubernetes 远远不止本文所介绍的这些内容。</p></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg>
<span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><aside class=related-content--wrapper><h2 class=section-title>Related content</h2><div class=related-content><div class="flex article-list--tile"><article><a href=/posts/prepare-istio-env/><div class=article-details><h2 class=article-title>prepare a devlopment environment for istio</h2></div></a></article><article><a href=/posts/minikube-env-preparatioin/><div class=article-details><h2 class=article-title>prepare a minikube environment</h2></div></a></article></div></div></aside><script src=https://utteranc.es/client.js repo=kee-life/blog issue-term=pathname label=Comments crossorigin=anonymous async></script><style>.utterances{max-width:unset}</style><script>let utterancesLoaded=!1;function setUtterancesTheme(e){let t=document.querySelector(".utterances iframe");t&&t.contentWindow.postMessage({type:"set-theme",theme:`github-${e}`},"https://utteranc.es")}addEventListener("message",e=>{if(e.origin!=="https://utteranc.es")return;utterancesLoaded=!0,setUtterancesTheme(document.documentElement.dataset.scheme)}),window.addEventListener("onColorSchemeChange",e=>{if(!utterancesLoaded)return;setUtterancesTheme(e.detail)})</script><footer class=site-footer><section class=copyright>&copy;
2017 -
2024 Personal blog</section><section class=powerby></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
</button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js integrity="sha256-ePwmChbbvXbsO02lbM3HoHbSHTHFAeChekF1xKJdleo=" crossorigin=anonymous defer></script><script src=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js integrity="sha256-UKkzOn/w1mBxRmLLGrSeyB4e1xbrp4xylgAWb3M42pU=" crossorigin=anonymous defer></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css crossorigin=anonymous><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css crossorigin=anonymous></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.6/dist/vibrant.min.js integrity="sha256-awcR2jno4kI5X0zL8ex0vi2z+KMkF24hUW8WePSA9HM=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const e=document.createElement("link");e.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap",e.type="text/css",e.rel="stylesheet",document.head.appendChild(e)})()</script></body></html>